/**
  ******************************************************************************
  * File Name          : freertos.c
  * Description        : Code for freertos applications
  ******************************************************************************
  * This notice applies to any and all portions of this file
  * that are not between comment pairs USER CODE BEGIN and
  * USER CODE END. Other portions of this file, whether 
  * inserted by the user or by software development tools
  * are owned by their respective copyright owners.
  *
  * Copyright (c) 2017 STMicroelectronics International N.V. 
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without 
  * modification, are permitted, provided that the following conditions are met:
  *
  * 1. Redistribution of source code must retain the above copyright notice, 
  *    this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  * 3. Neither the name of STMicroelectronics nor the names of other 
  *    contributors to this software may be used to endorse or promote products 
  *    derived from this software without specific written permission.
  * 4. This software, including modifications and/or derivative works of this 
  *    software, must execute solely and exclusively on microcontroller or
  *    microprocessor devices manufactured by or for STMicroelectronics.
  * 5. Redistribution and use of this software other than as permitted under 
  *    this license is void and will automatically terminate your rights under 
  *    this license. 
  *
  * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS" 
  * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT 
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
  * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
  * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT 
  * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
  * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"

/* USER CODE BEGIN Includes */     
#include "my_led.h"
#include "my_101.h"
//#include "my_cc1101.h"
#include "my_OS.h"
#include "bsp_iap.h"
#include "my_DAC.h"
/* USER CODE END Includes */

/* Variables -----------------------------------------------------------------*/
osThreadId defaultTaskHandle;
osThreadId myTask02Handle;
osThreadId myTask03Handle;
osThreadId myTask04Handle;
osThreadId myTask05Handle;
osThreadId myTask06Handle;
osThreadId myTask07Handle;
osThreadId myTask08Handle;
osMessageQId myQueue01Handle;
osMessageQId myQueue02Handle;
osMessageQId myQueue03Handle;
osMessageQId myQueue04Handle;
osTimerId myTimer01Handle;
osMutexId myMutex01Handle;

/* USER CODE BEGIN Variables */
extern uint16_t my_wave_write_add;

extern uint16_t my_dianliu_exit_add;
extern uint16_t my_Time_Cyc_exit_add;
extern uint8_t my_DC_AC_status;
extern uint8_t my_CC1101_Frame_status;
extern uint8_t my_CC1101_COM_Fram_buf[];
extern uint16_t  my_CC1101_all_step;
extern uint16_t my_PWR_all_step;
extern uint8_t USART3_FRAME_status;
extern uint8_t USART3_my_frame[];

extern uint8_t my_IT_status;


uint8_t   my_os_count1=0;

EventGroupHandle_t xCreatedEventGroup = NULL;
EventGroupHandle_t xCreatedEventGroup2 = NULL;

/* USER CODE END Variables */

/* Function prototypes -------------------------------------------------------*/
void StartDefaultTask(void const * argument);
void StartTask02(void const * argument);
void StartTask03(void const * argument);
void StartTask04(void const * argument);
void StartTask05(void const * argument);
void StartTask06(void const * argument);
void StartTask07(void const * argument);
void StartTask08(void const * argument);
void Callback01(void const * argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* USER CODE BEGIN FunctionPrototypes */

/* USER CODE END FunctionPrototypes */

/* Hook prototypes */

/* Init FreeRTOS */

void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */
       
  /* USER CODE END Init */

  /* Create the mutex(es) */
  /* definition and creation of myMutex01 */
  osMutexDef(myMutex01);
  myMutex01Handle = osMutexCreate(osMutex(myMutex01));

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* Create the timer(s) */
  /* definition and creation of myTimer01 */
  osTimerDef(myTimer01, Callback01);
  myTimer01Handle = osTimerCreate(osTimer(myTimer01), osTimerPeriodic, NULL);

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
	osTimerStart(myTimer01Handle, 1000);
  /* USER CODE END RTOS_TIMERS */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityIdle, 0, 128);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

  /* definition and creation of myTask02 */
  osThreadDef(myTask02, StartTask02, osPriorityNormal, 0, 256);
  myTask02Handle = osThreadCreate(osThread(myTask02), NULL);

  /* definition and creation of myTask03 */
  osThreadDef(myTask03, StartTask03, osPriorityNormal, 0, 128);
  myTask03Handle = osThreadCreate(osThread(myTask03), NULL);

  /* definition and creation of myTask04 */
  osThreadDef(myTask04, StartTask04, osPriorityNormal, 0, 128);
  myTask04Handle = osThreadCreate(osThread(myTask04), NULL);

  /* definition and creation of myTask05 */
  osThreadDef(myTask05, StartTask05, osPriorityNormal, 0, 256);
  myTask05Handle = osThreadCreate(osThread(myTask05), NULL);

  /* definition and creation of myTask06 */
  osThreadDef(myTask06, StartTask06, osPriorityNormal, 0, 256);
  myTask06Handle = osThreadCreate(osThread(myTask06), NULL);

  /* definition and creation of myTask07 */
  osThreadDef(myTask07, StartTask07, osPriorityNormal, 0, 128);
  myTask07Handle = osThreadCreate(osThread(myTask07), NULL);

  /* definition and creation of myTask08 */
  osThreadDef(myTask08, StartTask08, osPriorityAboveNormal, 0, 128);
  myTask08Handle = osThreadCreate(osThread(myTask08), NULL);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* Create the queue(s) */
  /* definition and creation of myQueue01 */
  osMessageQDef(myQueue01, 16, uint16_t);
  myQueue01Handle = osMessageCreate(osMessageQ(myQueue01), NULL);

  /* definition and creation of myQueue02 */
  osMessageQDef(myQueue02, 16, uint16_t);
  myQueue02Handle = osMessageCreate(osMessageQ(myQueue02), NULL);

  /* definition and creation of myQueue03 */
  osMessageQDef(myQueue03, 16, uint16_t);
  myQueue03Handle = osMessageCreate(osMessageQ(myQueue03), NULL);

  /* definition and creation of myQueue04 */
  osMessageQDef(myQueue04, 16, uint16_t);
  myQueue04Handle = osMessageCreate(osMessageQ(myQueue04), NULL);

  /* USER CODE BEGIN RTOS_QUEUES */
	
	  xCreatedEventGroup = xEventGroupCreate();
    xCreatedEventGroup2 = xEventGroupCreate();
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */
}

/* StartDefaultTask function */
void StartDefaultTask(void const * argument)
{

  /* USER CODE BEGIN StartDefaultTask */
	__HAL_GPIO_EXTI_CLEAR_IT(PIN_CC_IRQ);
	HAL_NVIC_EnableIRQ(EXIT_CC_IRQ_GD0); //开启中断，接收CC1101数据产生
	
  /* Infinite loop */
  for(;;)
  {
		//my_fun_CC1101_init_resume();
		my_fun_usart_init_resume();
		
    osDelay(10000);
  }
  /* USER CODE END StartDefaultTask */
}

/* StartTask02 function */
void StartTask02(void const * argument)
{
  /* USER CODE BEGIN StartTask02 */
  /* Infinite loop */
	 BaseType_t my_result;
    uint16_t my_step;
  for(;;)
  {
		//==CC1101 发送数据环节，对应队列1
		
    		my_result = xQueueReceive(myQueue01Handle, &my_step,10000); //xQueuePeek
        if(my_result == pdPASS)
        {
            printf("=========CC1101 CC_T_QU1 IS send=[%X]--------\r\n",my_step);
        }
        else
        {
            my_step = 0X00;
            //printf("M35 not receive step = %d\r\n",my_step);

        }
				
				
				
				
			//====0 DTU 在线升级--发送部分
				my_fun_CC1101_time_dialog_tx2(my_step, 0xF000, 0xF100, 0,my_fun_CC1101_test1);
				my_fun_CC1101_time_dialog_tx2(my_step, 0xF200, 0xF300, 0,my_fun_CC1101_test1);
				my_fun_CC1101_time_dialog_tx2(my_step, 0xF400, 0xF500, 0,my_fun_CC1101_test1);
				my_fun_CC1101_time_dialog_tx2(my_step, 0xF600, 0xF700, 0,my_fun_CC1101_test1);
				my_fun_CC1101_time_dialog_tx2(my_step, 0xF800, 0xF900, 1,my_fun_CC1101_test1);
				
		//=====2 发送周期数据
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x0100, 0,my_fun_TX_CC1101_test0);
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x4000, 0,my_fun_TX_CC1101_test1);
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x4100, 0,my_fun_TX_CC1101_test2);
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x4200, 0,my_fun_TX_CC1101_test3);
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x4300, 0,my_fun_TX_CC1101_test4);
		
   //====1 发送报警数据		
		    my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x0200, 0,my_fun_TX_CC1101_test0); //遥信
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x5000, 0,my_fun_TX_CC1101_test1); //遥测DC
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x5100, 0,my_fun_TX_CC1101_test2); //遥测AC
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x5200, 0,my_fun_TX_CC1101_test3); //遥测12TAC
				my_fun_CC1101_time_dialog_tx2(my_step, 0x0000, 0x5300, 0,my_fun_TX_CC1101_test4); //录波
		
		        LED2_TOGGLE;
            //osDelay(20000);
  }
  /* USER CODE END StartTask02 */
}

/* StartTask03 function */
void StartTask03(void const * argument)
{
  /* USER CODE BEGIN StartTask03 */
  /* Infinite loop */
		 BaseType_t my_result;
    uint16_t my_step;
  for(;;)
  {
		//CC1101接收数据环节，对应队列2
		 my_result = xQueueReceive(myQueue02Handle, &my_step, 1000); //xQueuePeek,队列2对应，M35接收队列
        if(my_result == pdPASS)
        {
            printf("-------CC1101 CC_R_QU2 receive=[ %X]\r\n",my_step);
        }
        else
        {
            //printf("CC1101 not receive step = %d\r\n",my_step);
            my_step = 0X0000;
        }
			
				
				//====DTU在线升级--接收部分--

				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x0000, 0xF000, 0xF100, 0,my_fun_write_update_data_to_FLASH);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x0000, 0xF200, 0xF300, 0,my_fun_write_update_data_to_FLASH);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x0000, 0xF400, 0xF500, 0,my_fun_write_update_data_to_FLASH);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x0000, 0xF600, 0xF700, 0,my_fun_write_update_data_to_FLASH);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x0000, 0xF800, 0xF900, 0,my_fun_write_update_data_to_FLASH);
		 //======周期接收部分===
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x0100, 0x2000, 0x4000, 0,my_fun_RX_CC1101_text0_RX_OK);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x4000, 0x2000, 0x4100, 0,my_fun_RX_CC1101_text0_RX_OK);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x4100, 0x2000, 0x4200, 0,my_fun_RX_CC1101_text0_RX_OK);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x4200, 0x2000, 0x4300, 0,my_fun_RX_CC1101_text0_RX_OK);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x4300, 0x2000, 0x0000, 1,my_fun_RX_CC1101_text0_RX_OK);
		//======  报警接收  ==		
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x0200, 0x2000, 0x5000, 0,my_fun_RX_CC1101_text0_RX_OK);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x5000, 0x2000, 0x5100, 0,my_fun_RX_CC1101_text0_RX_OK);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x5100, 0x2000, 0x5200, 0,my_fun_RX_CC1101_text0_RX_OK);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x5200, 0x2000, 0x5300, 0,my_fun_RX_CC1101_text0_RX_OK);
				my_fun_CC1101_time_dialog_rx2(&myQueue01Handle, my_step, 0x5300, 0x2000, 0x0000, 1,my_fun_RX_CC1101_text0_RX_OK);
				
		
		//LED4_TOGGLE
    //osDelay(1000);
  }
  /* USER CODE END StartTask03 */
}

/* StartTask04 function */
void StartTask04(void const * argument)
{
  /* USER CODE BEGIN StartTask04 */
  /* Infinite loop */
	
	  uint8_t my_status = 0;
	  uint8_t temp8=0;
	  uint16_t my_step=0;
  for(;;)
  {
		//CC1101协议帧检测，对应标志组1，的0000 1000的这位1，有命令帧，发送状态到接收队列2
		 
     //=========
  		EventBits_t	uxBits = xEventGroupWaitBits(xCreatedEventGroup, /* 事件标志组句柄 */
                             0x08,            /* 等待bit0和bit1被设置 */
                             pdTRUE,             /* 退出前bit0和bit1被清除，这里是bit0和bit1都被设置才表示“退出”*/
                             pdTRUE,             /* 设置为pdTRUE表示等待bit1和bit0都被设置*/
                             3000); 	 /* 等待延迟时间 */

        if((uxBits & 0x08) == 0x08)
        {
            my_status = 1; //通过标志组，获得接收到数据的标志
            //printf("cc1101 receive data !\r\n");
        }			
				else 
					my_status=0;
				//=========
			
				//把CC101接收到的数据移动到缓冲区中
				if(my_status == 1)
				{
					if(RF_RecvHandler_intrrupt_get_data_to_buf()>0)
						my_status=1;
					else 
						my_status=0;
					
				}	
		//============
				
					//对缓冲区进行帧分析				
        if(my_status == 1)
        {
        
					//协议解析，获得一帧数据
					my_101frame_analyse(4,1,CC1101_CRC_check);
      //=========取功能码===
					 if(my_CC1101_Frame_status>0)  //分析出来数据
					{						
					
						//my_fun_display_fram_16(4);  //测试使用，显示接收到的数据
						
						my_CC1101_Frame_status=0;
						
						if(my_CC1101_COM_Fram_buf[0]==0x10)	
						{							
							my_status=0x10;
							temp8=my_CC1101_COM_Fram_buf[1]; //功能码为0X20，代表OK帧
						}
						else if (my_CC1101_COM_Fram_buf[0]==0x68)
						{							
						  my_status=0x68;
							temp8=my_CC1101_COM_Fram_buf[6]; //功能码为0X20，代表OK帧
						}
						else 
						{
						 my_status=0;		
						 temp8=0;
						}
					}
				//====功能码分析部分===
						if(temp8!=0x00) 
						{
							printf("CC1101 now_step=[%x], get_step= [%x]\r\n",my_CC1101_all_step,temp8);
							
						}
						//==1=OK帧对话工程
						  if( temp8==0x20)
						 {
							  my_step=0X2000;
							 xQueueSend(myQueue02Handle,&my_step,100);								 
						 }
						//===2====
						
						
						//==3 ====升级对话过程
				    else if( temp8==0xF0)
						 {						 
							 //my_CC1101_all_step=0XF000; //对话过程的开始状态
							 my_step=0XF000;
							 xQueueSend(myQueue02Handle,&my_step,100);									 
						 }
						 else if( temp8==0xF2)
						 {						 
							  my_step=0XF200;
							 xQueueSend(myQueue02Handle,&my_step,100);								 
						 }
						  else if( temp8==0xF4)
						 {
							 my_CC1101_all_step=0XF400;
							  my_step=0XF400;
							 xQueueSend(myQueue02Handle,&my_step,100);									 
						 }
						 else if( temp8==0xF6)
						 {						 					
							 my_step=0XF600;
							 xQueueSend(myQueue02Handle,&my_step,100);									 
						 }
						  else if( temp8==0xF8)
						 {
							  my_step=0XF800;
							 xQueueSend(myQueue02Handle,&my_step,100);								 
						 }
						 
						 //===
						 
						//===============
						 
						temp8=0;
						my_CC1101_Frame_status=0;
						my_status=0;
						 
					 }				
    //osDelay(1);
  }
  /* USER CODE END StartTask04 */
}

/* StartTask05 function */
void StartTask05(void const * argument)
{
  /* USER CODE BEGIN StartTask05 */
  /* Infinite loop */
	  BaseType_t my_result;
    uint16_t my_step;
  for(;;)
  {    
		
		    //串口发送处理
				my_result = xQueueReceive(myQueue03Handle, &my_step,4000); //xQueuePeek
        if(my_result == pdPASS)
        {
            printf("--------UART3 T_QU3 IS send=[%X]\r\n",my_step);
        }
        else
        {
            my_step = 0X00;
            //printf("M35 not receive step = %d\r\n",my_step);

        }
				//发送心跳
		   my_fun_PWR_time_dialog_tx2(my_step, 0x0000, 0x1F00, 0,my_fun_TX_UART3_test0); 
				//发送OK帧
			 my_fun_PWR_time_dialog_tx2(my_step, 0x4000, 0x2000, 0,my_fun_TX_UART3_test0); 
		   
				//LED3_TOGGLE;
		
    //osDelay(1000);
  }
  /* USER CODE END StartTask05 */
}

/* StartTask06 function */
void StartTask06(void const * argument)
{
  /* USER CODE BEGIN StartTask06 */
  /* Infinite loop */
	BaseType_t my_result;
    uint16_t my_step;
  for(;;)
  {
		
		    //=========串口接收处理
		    my_result = xQueueReceive(myQueue04Handle, &my_step, 1000); //xQueuePeek,队列2对应，M35接收队列
        if(my_result == pdPASS)
        {
            printf("----------UART3 R_QU4 receive=[ %X]\r\n",my_step);
        }
        else
        {
            
            my_step = 0X0000;
					
        }
		  	my_fun_PWR_time_dialog_rx2(&myQueue03Handle, my_step, 0x0000, 0x4000, 0x2000, 0,my_fun_RX_UART3_text0_RX_OK);
				my_fun_PWR_time_dialog_rx2(&myQueue03Handle, my_step, 0x1F00, 0x2000, 0x0000, 1,my_fun_RX_UART3_text0_RX_OK);
		
		
    //osDelay(1);
  }
  /* USER CODE END StartTask06 */
}

/* StartTask07 function */
void StartTask07(void const * argument)
{
  /* USER CODE BEGIN StartTask07 */
  /* Infinite loop */
	
	  uint8_t my_status = 0;
	  uint8_t temp8=0;
	  uint16_t my_step=0;
	
  for(;;)
  {
		
		  //=====串口3====
  		EventBits_t	uxBits = xEventGroupWaitBits(xCreatedEventGroup, /* 事件标志组句柄 */
                             0x04,            /* 等待bit0和bit1被设置 */
                             pdTRUE,             /* 退出前bit0和bit1被清除，这里是bit0和bit1都被设置才表示“退出”*/
                             pdTRUE,             /* 设置为pdTRUE表示等待bit1和bit0都被设置*/
                             3000); 	 /* 等待延迟时间 */

        if((uxBits & 0x04) == 0x04)
        {
            my_status = 1; //通过标志组，获得接收到数据的标志
          }			
				else 
					my_status=0;
			
		//============
				
					//对缓冲区进行帧分析				
        if(my_status == 1)
        {
        
					//协议解析，获得一帧数据
					my_101frame_analyse(3,1,CC1101_CRC_check);
      //=========取功能码===
					 if(USART3_FRAME_status>0)  //分析出来数据
					{						
					
						my_fun_display_fram_16(3);  //测试使用，显示接收到的数据
						
						USART3_FRAME_status=0;
						
						if(USART3_my_frame[0]==0x10)	
						{							
							my_status=0x10;
							temp8=USART3_my_frame[1]; //功能码为0X20，代表OK帧
						}
						else if (USART3_my_frame[0]==0x68)
						{							
						  my_status=0x68;
							temp8=USART3_my_frame[6]; //功能码为0X20，代表OK帧
						}
						else 
						{
						 my_status=0;		
						 temp8=0;
						}
					}
				//====功能码分析部分===
						if(temp8!=0x00) 
						{
							printf("my_PWR_now_step=[%x], get_step= [%x]\r\n",my_PWR_all_step,temp8);
							
						}
						//==1=OK帧对话工程
						  if( temp8==0x20)
						 {
							  my_step=0X2000;
							 xQueueSend(myQueue04Handle,&my_step,100);								 
						 }
						//===2====
						
				    else if( temp8==0x40)
						 {						 
							 //my_CC1101_all_step=0XF000; //对话过程的开始状态
							 my_step=0X4000;
							 xQueueSend(myQueue04Handle,&my_step,100);									 
						 }
										 
						//===============
						 
						temp8=0;
						USART3_FRAME_status=0;
						my_status=0;
						 
					 }				
		
    //osDelay(1);
  }
  /* USER CODE END StartTask07 */
}

/* StartTask08 function */
void StartTask08(void const * argument)
{
  /* USER CODE BEGIN StartTask08 */
  /* Infinite loop */
	  uint8_t my_status = 0;
	  uint8_t temp8=0;
	  uint16_t my_step=0;
		HAL_NVIC_EnableIRQ(EXTI1_IRQn); //短路中断开启
  for(;;)
  { 
		
		EventBits_t	uxBits = xEventGroupWaitBits(xCreatedEventGroup2, /* 事件标志组句柄 */
                             0x01,            /* 等待bit0被设置 */
                             pdTRUE,             /* 退出前bit0和bit1被清除，这里是bit0和bit1都被设置才表示“退出”*/
                             pdTRUE,             /* 设置为pdTRUE表示等待bit1和bit0都被设置*/
                             200); 	 /* 等待延迟时间 */

        if((uxBits & 0x01) == 0x01)
        {
            my_status = 1; //通过标志组，获得接收到数据的标志
            //printf("cc1101 receive data !\r\n");
        }			
				else 
					my_status=0;
				//=========
		  	if(my_status == 1)
				{
					//启动中断判断，建立各种判据，判据获得全，得出结论后，进入对话信息发送环节
					//如果是同步录波，考虑立刻发送同步信号，然后开始自己录波，有待验证
					temp8=my_fun_current_exit_just();
				}
				
				if(my_IT_status==1)
				{
					temp8=my_fun_current_exit_just();
					
					if(temp8==1)
					{
							//进入数据发送环节
							my_step=0X0200;
							 xQueueSend(myQueue01Handle,&my_step,100);			
					}						
				}
		
		
    //osDelay(1000);
  }
  /* USER CODE END StartTask08 */
}

/* Callback01 function */
void Callback01(void const * argument)
{
  /* USER CODE BEGIN Callback01 */

my_os_count1++; //1秒钟，中断一次
	
	
	  
#if ADC_CYC_data==1  //开启周期采样
			  if(my_os_count1 % (25) == 0 && my_os_count1 != 0)      
    {
          my_fun_give_Queue(&myQueue01Handle,0X0100);  //发送周期数据			   
    }		
#endif 

#if DAC_auto_change_on==1
		if(my_os_count1%(27)==0)  
		{
			my_fun_Set_DAC_I_ref();//DA转换
			
		}
#endif	
		
		if(my_os_count1 % (300) == 0 && my_os_count1 != 0)      
    {
         //my_fun_give_Queue(&myQueue03Handle,0X1F00);  //向PWR发送心跳数据
			   
    }
		
		#if OS_heap_high_water_data==1
		if(my_os_count1 % (100) == 0 && my_os_count1 != 0)      
    {
 		my_fun_task_heap_value();			   
    }
		#endif
		
		
		
	LED7_TOGGLE;
  /* USER CODE END Callback01 */
}

/* USER CODE BEGIN Application */
     
/* USER CODE END Application */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
