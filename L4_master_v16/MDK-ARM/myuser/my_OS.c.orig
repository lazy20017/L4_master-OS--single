#include "my_OS.h"
#include "my_usart.h"
#include "my_ADC.h"
#include "my_wave_rec.h"
#include "my_101.h"
#include "my_extern_val.h"

extern EventGroupHandle_t xCreatedEventGroup;
extern osMessageQId myQueue01Handle;
extern osMessageQId myQueue02Handle;
extern osMutexId myMutex01Handle;

extern osThreadId defaultTaskHandle;
extern osThreadId myTask02Handle;
extern osThreadId myTask03Handle;
extern osThreadId myTask04Handle;
extern osThreadId myTask05Handle;
extern osThreadId myTask06Handle;
extern osThreadId myTask07Handle;
extern osThreadId myTask08Handle;



extern uint8_t my_CC1101_dest_address;
extern uint8_t my_cc1101_tx_buf[];
extern uint8_t my_CC1101_COM_Fram_buf[];


extern uint16_t my_wave_write_add;
extern uint16_t my_dianliu_exit_add;
extern uint16_t my_Time_Cyc_exit_add;
extern uint8_t my_DC_AC_status;
extern uint8_t my_CC1101_Frame_status;
extern uint8_t my_CC1101_COM_Fram_buf[];
extern uint16_t  my_CC1101_all_step;


extern uint8_t my_UART1_Status;
extern uint8_t my_UART2_Status;
extern uint8_t my_UART3_Status;

uint16_t  my_GPRS_all_step=0;
uint8_t my_GPRS_all_count=0;
uint16_t  my_CC1101_all_step=0;
uint8_t  my_CC1101_all_count=0;
uint16_t my_PWR_all_step=0;
uint8_t my_PWR_all_count=0;

uint8_t temp8=0;

void my_fun_give_Queue(osMessageQId *my_QHL,uint16_t temp_step)
{
    BaseType_t pt=NULL;
    BaseType_t xResult;
    xResult=xQueueSendFromISR(*my_QHL,&temp_step,&pt); //队列1对应，M35的发送状态队列

    if(xResult!=pdFAIL)
    {
        //printf(" send QH OK--[%X]\r\n",temp_step);
        portYIELD_FROM_ISR(pt);

    }
    else
    {
        printf(" send QH ERROR--[%X]\r\n",temp_step);

    }
    //printf("queue3 is %d\r\n",temp8);
}


//=====CC1101发送使用

//============
void my_fun_CC1101_time_dialog_tx2(
    uint16_t my_get_step,
    uint16_t my_before_step,
    uint16_t my_now_step,
    uint8_t end_status,
    void (*ptfun)(void)
)
{
    //===判断部分
    if(my_get_step==my_now_step && my_before_step==0X00)
    {
        //printf("CC1101 TX--step = [%x]\r\n",my_now_step);
        my_CC1101_all_count=0;
        my_CC1101_all_step=my_now_step;
        my_get_step=0;
    }
    else if(my_get_step==my_now_step && my_before_step==my_CC1101_all_step)
    {
        // printf("CC1101 TX--step = [%x]\r\n",my_now_step);
        my_CC1101_all_count=0;
        my_CC1101_all_step=my_now_step;
        my_get_step=0;
    }

    //===重复发送部分
    if( my_now_step==my_CC1101_all_step && my_CC1101_all_count<3 )
    {
        my_CC1101_all_count++;
        printf("CC1101 TX-Fun= [%X]--%d\r\n",my_now_step,my_CC1101_all_count);
        //osDelay(1);
        //HAL_Delay(1);//CC1101发送数据，要延时一下，因为操作系统任务切换需要1ms
        ptfun();		//调用对应的函数
    }
    else if(my_CC1101_all_count>=3)
    {
			
        my_CC1101_all_count=0;
        my_CC1101_all_step=0x00;
			  if(my_CC1101_Sleep_status==1)
				{
					CC1101SetSleep();
				}
    }

    //====只发送一次就结束
    if(end_status==1 && my_CC1101_all_count>0 && my_CC1101_all_step==my_now_step )
    {
        my_CC1101_all_count=0;
        my_CC1101_all_step=0x00;
			
				if(my_CC1101_Sleep_status==1)
				{
					CC1101SetSleep();
				}
			
    }

}


//==========
void my_fun_CC1101_time_dialog_rx2(
    osMessageQId *QHL_send,
    uint16_t my_get_step,   //
    uint16_t my_before_step,
    uint16_t my_now_step,
    uint16_t my_next_step,
    uint8_t end_status,
    uint8_t (*ptfun)(void)
)
{
    uint8_t my_status=0;
    uint8_t my_temp=0;
    //=====0====
    if(my_get_step==my_now_step && my_before_step==0x00)  //无条件处理接收到的数据
    {
        my_status=1;
    }
    else if(my_get_step==my_now_step && my_before_step==my_CC1101_all_step)  //条件绑定，有前提条件
    {
        my_status=1;
    }
    else
    {
        return;
    }
    //======1=====
    if(my_status==1 && end_status==0)
    {
        //printf("CC1101 RX-step = [%x]\r\n",my_now_step);
        my_temp=ptfun();
        if(my_temp==1)
        {
            my_CC1101_all_step=my_now_step;	//当前状态
            xQueueSend(*QHL_send,&my_next_step,100);	//标识下一个状态
        }
        else
            printf("接收数据错误，不进行状态转换\r\n");
    }
    else if(my_status==1 && end_status==1)
    {
        // printf("CC1101 RX-step = [%x]\r\n",my_now_step);
        ptfun();
        my_CC1101_all_step=0X00; //结束状态
			 
			  if(my_CC1101_Sleep_status==1)
				{
					CC1101SetSleep();
				}

    }

    //

}


//=========
//#define com_long_10  "\x10\x20\x3\x4\x5\x6\x7\x16"
//#define com_short_68 "\x68\x04\x04\x68\x1\x2\x3\x4\x5\x16"
//#define com_long_68 "\x68\x05\x00\x05\x00\x68\x1\x2\x3\x4\x5\x6\x16"
//uint8_t my_buf2[]=com_long_10;
//uint8_t my_buf3[]=com_short_68;
//uint8_t my_buf4[]=com_long_68;
//uint8_t my_cc1101_tx_buf[64]={0x10,0x20,0x13,0x14,0x15,0x16};


uint8_t my_heart_count=0;
void my_fun_CC1101_test2(void)
{
    uint8_t temp_status=0;
    if(my_CC1101_COM_Fram_buf[0]==0x10)
    {
        temp_status=my_CC1101_COM_Fram_buf[1];
        my_fun_display_buf_16(my_CC1101_COM_Fram_buf,8,0);
    }
    else if (my_CC1101_COM_Fram_buf[0]==0x68)
    {
        temp_status=my_CC1101_COM_Fram_buf[6];
        my_fun_display_buf_16(my_CC1101_COM_Fram_buf,8,0);
    }

    if(temp_status==0x75)
        printf("====CC heart count %d=======\r\n",my_heart_count++);
    else if(temp_status==0xF0)
    {
        printf("接收升级数据开始  F0\r\n");
    }
    else if(temp_status==0xF2)
    {
        printf("接收升级数据开始  block=%d   F2\r\n",my_CC1101_COM_Fram_buf[7]);
    }
    else if(temp_status==0xF4)
    {
        printf("接收最后的数据包   F4\r\n");
    }
    else if(temp_status==0xF6)
    {
        printf("接收最后的数据包   block=%d  F6\r\n",my_CC1101_COM_Fram_buf[7]);
    }
    else if(temp_status==0xF8)
    {
        printf("升级数据传输结束   F8\r\n");
    }


}
//=====================
//指示器模拟程序部分，用来模拟指示器的数据发送给DTU
//1A--1,1B--2,1C--3    2A--1,2B--2,2C--3    3A--1,3B--2,3C--3
void my_fun_indicator_heart_awaken_send(void)
{
    //10-71-LL-YY-01-00-CRC-16
    static uint8_t count=0;
    uint8_t indicator_ABC=1;
    count++;
    my_cc1101_tx_buf[0]=0x10;
    my_cc1101_tx_buf[1]=0X71;
    my_cc1101_tx_buf[2]=indicator_ABC;
    my_cc1101_tx_buf[3]=00;
    my_cc1101_tx_buf[4]=count;
    my_cc1101_tx_buf[5]=00;
    my_cc1101_tx_buf[6]=count;
    my_cc1101_tx_buf[7]=0X16;

    CC1101SendPacket_add(my_cc1101_tx_buf,8,ADDRESS_CHECK,my_CC1101_dest_address);
    my_fun_display_buf_16(my_cc1101_tx_buf,8,1); //测试使用
}
//1A--1,1B--2,1C--3    2A--1,2B--2,2C--3    3A--1,3B--2,3C--3
void my_fun_indicator_heart_data_send(void)
{
    //10-71-LL-YY-01-00-CRC-16
    static uint8_t count=0;
    uint8_t indicator_ABC=1;
    count++;

    my_cc1101_tx_buf[0]=0x10;
    my_cc1101_tx_buf[1]=0X73;
    my_cc1101_tx_buf[2]=indicator_ABC;
    my_cc1101_tx_buf[3]=00;
    my_cc1101_tx_buf[4]=count;
    my_cc1101_tx_buf[5]=00;
    my_cc1101_tx_buf[6]=count;
    my_cc1101_tx_buf[7]=0X16;

    CC1101SendPacket_add(my_cc1101_tx_buf,8,ADDRESS_CHECK,my_CC1101_dest_address);
    my_fun_display_buf_16(my_cc1101_tx_buf,8,1); //测试使用
}

void my_fun_indicator_heart_data_send2(void)
{
    //10-71-LL-YY-01-00-CRC-16
    static uint8_t count=0;
    uint8_t indicator_ABC=1;
    count++;

    my_cc1101_tx_buf[0]=0x10;
    my_cc1101_tx_buf[1]=0X75;
    my_cc1101_tx_buf[2]=indicator_ABC;
    my_cc1101_tx_buf[3]=00;
    my_cc1101_tx_buf[4]=count;
    my_cc1101_tx_buf[5]=00;
    my_cc1101_tx_buf[6]=count;
    my_cc1101_tx_buf[7]=0X16;

    CC1101SendPacket_add(my_cc1101_tx_buf,8,ADDRESS_CHECK,my_CC1101_dest_address);
    my_fun_display_buf_16(my_cc1101_tx_buf,8,1); //测试使用
}


//=========接收处理函数==========
uint8_t my_fun_GPRS_RX_test1(void) //此函数为结束函数，收到OK帧后，结束对话过程
{

    printf("GPRS dialog is Finish!---[%X]\r\n",my_GPRS_all_step);
    return 1;

}

//遥信接收到OK帧
uint8_t my_fun_GPRS_RX_test2(void)  //接收到过程帧，不做处理
{

    printf("GPRS dialog get OK frame---[%X]\r\n",my_GPRS_all_step);
    return 1;
}
//===CC1101,发送处理函数
void my_fun_TX_CC1101_test0(void)  //遥信
{

    //=====0 发送遥信数据包
    if(my_CC1101_all_step==0x0001)
    {
        
				//启动周期录波
        if(my_CC1101_all_count==1)
        {
            my_dianliu_exit_add = my_wave_write_add;
            my_Time_Cyc_exit_add = my_wave_write_add;
            my_adc_1_convert(); //计算直流值（ADC1的4个分量）
#if USE_olde_12T_data_cyc==0
            my_fun_wave_rec();  //1级缓冲到2级缓冲
#else
            my_fun_wave1_to_wave2_old_data();
#endif

            my_adc2_convert2(0); //计算12个周期的每个周期的3个分量，和12个周期的累计平均值
        }
			
			
			//==周期
        my_fun_101send_Alarm_status_data(&huart2,my_DC_AC_status, 0X01);
    }
    else if(my_CC1101_all_step==0x0002)
    {
        //==报警
        my_fun_101send_Alarm_status_data(&huart2,my_DC_AC_status, 0X02);
    }



#if OS_CC1101_auto_reveive_OK==1
    my_fun_give_Queue(&myQueue02Handle,0x2000); //@@@@@
#endif


}

void my_fun_TX_CC1101_test1(void)  //遥测 直流
{
    if(my_CC1101_all_step==0x0040) //周期
    {
//			//启动周期录波
//        if(my_CC1101_all_count==1)
//        {
//            my_dianliu_exit_add = my_wave_write_add;
//            my_Time_Cyc_exit_add = my_wave_write_add;
//            my_adc_1_convert(); //计算直流值（ADC1的4个分量）
//#if USE_olde_12T_data_cyc==0
//            my_fun_wave_rec();  //1级缓冲到2级缓冲
//#else
//            my_fun_wave1_to_wave2_old_data();
//#endif

//            my_adc2_convert2(0); //计算12个周期的每个周期的3个分量，和12个周期的累计平均值
//        }
        //=====1 发送直流数据包
        my_fun_101send_DC_data(&huart2,my_DC_AC_status, 0X40); //发送直流数据
    }
    else if(my_CC1101_all_step==0x0050)
    {
        //====报警
        my_fun_101send_DC_data(&huart2,my_DC_AC_status, 0X50); //发送直流数据

    }

#if Debug_Usart_OUT_DC_DATA_status==1

    my_adc_1_convert_dis(0);
#endif

#if OS_CC1101_auto_reveive_OK==1
    my_fun_give_Queue(&myQueue02Handle,0x2000); //@@@@@
#endif




}
void my_fun_TX_CC1101_test2(void)  //遥测 交流有效值
{

    if(my_CC1101_all_step==0x0041)  //交流有效值
    {
        //===2发送AC
        my_fun_101send_AC_data(&huart2,my_DC_AC_status, 0X41); //
    }
    else if(my_CC1101_all_step==0x0051)
    {
        //报警
        my_fun_101send_AC_data(&huart2,my_DC_AC_status, 0X51); //
    }
    //====	2 发送交流数据包


#if OS_CC1101_auto_reveive_OK==1
    my_fun_give_Queue(&myQueue02Handle,0x2000); //@@@@@
#endif

}

void my_fun_TX_CC1101_test3(void)
{


    if(my_CC1101_all_step==0x0042)
    {
        //=====3  发送12个周期的有效值12TAC
        my_fun_101send_AC12T_Cyc_data(&huart2,my_DC_AC_status, 0X42); //
    }
    else if(my_CC1101_all_step==0x0052)
    {
        //==报警
        my_fun_101send_AC12T_Cyc_data(&huart2,my_DC_AC_status, 0X52); //

    }


#if OS_CC1101_auto_reveive_OK==1
    my_fun_give_Queue(&myQueue02Handle,0x2000); //@@@@@
#endif

}

void my_fun_TX_CC1101_test4(void)
{
    if(my_CC1101_all_step==0x0043)
    {
        //=====4  发送录波数据，周期
#if CC1101_960data_Efield_STATUS==1
        my_fun_101send_AC_Rec_data(&huart2,my_DC_AC_status, 0X44); //960电场
#else
        my_fun_101send_AC_Rec_data(&huart2,my_DC_AC_status, 0X43); //960全波电流
#endif
        //my_fun_101send_AC_Rec_data(&huart2,my_DC_AC_status, 0X50);
    }
    else if(my_CC1101_all_step==0x0053)
    {
        //====录波数据，报警
        //my_fun_101send_AC_Rec_data(&huart2,my_DC_AC_status, 0X53); //
        my_fun_101send_AC_Rec_data(&huart2,my_DC_AC_status, 0X51); //
    }

#if CC1101_TX_Delay==1
    osDelay(2000);
#endif

#if Debug_Usart_out_ADCdata==1
    my_adc2_convert_dis(0); //@@@ 发送显示数据AC，到调试串口
#endif
#if OS_CC1101_auto_reveive_OK==1
    my_fun_give_Queue(&myQueue02Handle,0x2000); //@@@@@
#endif

}

void my_fun_CC1101_test1(void)
{
    uint8_t *pt;
    uint8_t my_step=0;
    uint8_t indicator_ABC=1;
    if(my_step==0)
    {
        my_cc1101_tx_buf[0]=0x10;
        my_cc1101_tx_buf[1]=0X20;
        my_cc1101_tx_buf[2]=indicator_ABC;
        my_cc1101_tx_buf[3]=00;
        my_cc1101_tx_buf[4]=00;
        my_cc1101_tx_buf[5]=00;
        my_cc1101_tx_buf[6]=00;
        my_cc1101_tx_buf[7]=0X16;
        pt=my_cc1101_tx_buf;
        pt[6]=my_fun_101check_generate(pt,1);
        HAL_Delay(100);
        CC1101SendPacket_add( pt,8,  ADDRESS_CHECK, my_CC1101_dest_address);
        my_fun_display_buf_16(pt,8,1); //测试使用

    }


}

//===CC1101  接收对话
uint8_t my_fun_RX_CC1101_text0_RX_OK(void)
{


    return 1;
}






void my_fun_PWR_time_dialog_tx2(
    uint16_t my_get_step,
    uint16_t my_before_step,
    uint16_t my_now_step,
    uint8_t end_status,
    void (*ptfun)(void)
)
{
    //===判断部分
    if(my_get_step==my_now_step && my_before_step==0X00)
    {
        //printf("CC1101 TX--step = [%x]\r\n",my_now_step);
        my_PWR_all_count=0;
        my_PWR_all_step=my_now_step;
        my_get_step=0;
    }
    else if(my_get_step==my_now_step && my_before_step==my_PWR_all_step)
    {
        // printf("CC1101 TX--step = [%x]\r\n",my_now_step);
        my_PWR_all_count=0;
        my_PWR_all_step=my_now_step;
        my_get_step=0;
    }

    //===重复发送部分
    if( my_now_step==my_PWR_all_step && my_PWR_all_count<3 && my_get_step==0)
    {
        my_PWR_all_count++;
        printf("PWR TX-Fun= [%X]--%d\r\n",my_now_step,my_PWR_all_count);
        //osDelay(1);
        //HAL_Delay(1);//CC1101发送数据，要延时一下，因为操作系统任务切换需要1ms
        ptfun();		//调用对应的函数
    }
    else if(my_PWR_all_count>=3)
    {
        my_PWR_all_count=0;
        my_PWR_all_step=0x00;
    }

    //====只发送一次就结束
    if(end_status==1 && my_PWR_all_count>0 && my_PWR_all_step==my_now_step && my_get_step==0)
    {
        my_CC1101_all_count=0;
        my_PWR_all_step=0x00;
    }

}


//==========
void my_fun_PWR_time_dialog_rx2(
    osMessageQId *QHL_send,
    uint16_t my_get_step,   //
    uint16_t my_before_step,
    uint16_t my_now_step,
    uint16_t my_next_step,
    uint8_t end_status,
    uint8_t (*ptfun)(void)
)
{
    uint8_t my_status=0;
    uint8_t my_temp=0;
    //=====0====
    if(my_get_step==my_now_step && my_before_step==0x00)  //无条件处理接收到的数据
    {
        my_status=1;
    }
    else if(my_get_step==my_now_step && my_before_step==my_PWR_all_step)  //条件绑定，有前提条件
    {
        my_status=1;
    }
    else
    {
        return;
    }
    //======1=====
    if(my_status==1 && end_status==0)
    {
        //printf("CC1101 RX-step = [%x]\r\n",my_now_step);
        my_temp=ptfun();
        if(my_temp==1)
        {
            my_PWR_all_step=my_now_step;	//当前状态
            xQueueSend(*QHL_send,&my_next_step,100);	//标识下一个状态
        }
        else
            printf("接收数据错误，不进行状态转换\r\n");
    }
    else if(my_status==1 && end_status==1)
    {
        // printf("CC1101 RX-step = [%x]\r\n",my_now_step);
        ptfun();
        my_PWR_all_step=0X00; //结束状态

    }

    //

}

/*
功能：CC1101重新初始化
*/
void my_fun_CC1101_init_resume(void)
{
    uint8_t my_status=0;
    //xSemaphoreTake(myMutex01Handle,1000);
    my_status=CC1101ReadStatus(CC1101_MARCSTATE);
    //xSemaphoreGive(myMutex01Handle);


    if(my_status!=0x01&& my_status!=0x0D &&  my_status!=0x13  ) //0X01空闲，0X0D接收，0X13发送,0x11接收溢出
    {
        printf("--error CC_status=[%X] \n",my_status);
        my_fun_CC1101_init_reum();
        printf("--inint after CC_status=[%X] \n",my_status);
    }

}

void my_fun_usart_init_resume(void)
{

    if(my_UART2_Status==0X01)
    {
        MX_USART2_UART_Init();
        my_UART2_Status=0;
        HAL_UART_Receive_IT(&huart2,&rsbuf2[rsbuf2pt_write],1);  //开启接收USART3函数
    }
}

void my_fun_task_heap_value(void)
{

    portBASE_TYPE uxHighWaterMark;

    uxHighWaterMark=uxTaskGetStackHighWaterMark( defaultTaskHandle );
    printf("task01 heap value=%d\r\n",uxHighWaterMark);

    uxHighWaterMark=uxTaskGetStackHighWaterMark( myTask02Handle );
    printf("task02 heap value=%d\r\n",uxHighWaterMark);
    uxHighWaterMark=uxTaskGetStackHighWaterMark( myTask03Handle );
    printf("task03 heap value=%d\r\n",uxHighWaterMark);
    uxHighWaterMark=uxTaskGetStackHighWaterMark( myTask04Handle );
    printf("task04 heap value=%d\r\n",uxHighWaterMark);
    uxHighWaterMark=uxTaskGetStackHighWaterMark( myTask05Handle );
    printf("task05 heap value=%d\r\n",uxHighWaterMark);
    uxHighWaterMark=uxTaskGetStackHighWaterMark( myTask06Handle );
    printf("task06 heap value=%d\r\n",uxHighWaterMark);
    uxHighWaterMark=uxTaskGetStackHighWaterMark( myTask07Handle );
    printf("task07 heap value=%d\r\n",uxHighWaterMark);
    uxHighWaterMark=uxTaskGetStackHighWaterMark( myTask08Handle );
    printf("task08 heap value=%d\r\n",uxHighWaterMark);


}
